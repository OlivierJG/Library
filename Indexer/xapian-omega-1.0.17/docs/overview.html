<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Omega overview</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="omega-overview">
<h1 class="title">Omega overview</h1>

<p>If you just want a very quick overview, you might prefer to read the
<a class="reference external" href="quickstart.html">quick-start guide</a>.</p>
<p>Omega operates on a set of databases.  Each database is created and updated
separately using either omindex or <a class="reference external" href="scriptindex.html">scriptindex</a>.  You can
search these databases (or any other Xapian database with suitable contents)
via a web front-end provided by omega, a CGI application.  A search can also be
done over more than one database at once.</p>
<p>There are separate documents covering <a class="reference external" href="cgiparams.html">CGI parameters</a>, the
<a class="reference external" href="termprefixes.html">Term Prefixes</a> which are conventionally used, and
<a class="reference external" href="omegascript.html">OmegaScript</a>, the language used to define omega's web
interface.  Omega ships with several OmegaScript templates and you can
use these, modify them, or just write your own.  See the &quot;Supplied Templates&quot;
section below for details of the supplied templates.</p>
<p>Omega parses queries using the <tt class="docutils literal"><span class="pre">Xapian::QueryParser</span></tt> class - for the supported
syntax, see queryparser.html in the xapian-core documentation
- available online at: <a class="reference external" href="http://xapian.org/docs/queryparser.html">http://xapian.org/docs/queryparser.html</a></p>
<div class="section" id="term-construction">
<h1>Term construction</h1>
<p>Documents within an omega database are stored with two types of terms:
those used for probabilistic searching (the CGI parameter 'P'), and
those used for boolean filtering (the CGI parameter 'B'). Boolean
terms start with an initial capital letter denoting the 'group' of the
term (e.g. 'M' for MIME type), while probabilistic terms are all
lower-case, and are also stemmed before adding to the
database.</p>
<p>The &quot;english&quot; stemmer is used by default - you can configure this for omindex
and scriptindex with &quot;--stemmer LANGUAGE&quot; (use 'none' to disable stemming, see
omindex --help for the list of accepted language names).  At search time you
can configure the stemmer by adding $set{stemmer,LANGUAGE} to the top of you
OmegaScript template.</p>
<p>The two term types are used as follows when building the query:
B(oolean) terms with the same prefix are ORed together, with all the
different prefix groups being ANDed together. This is then FILTERed
against the P(robabilistic) terms. This will look something like:</p>
<pre class="literal-block">
     [ FILTER ]
      /      \
     /        \
P-terms      [     AND     ]
              /     | ... \
             /
       [    OR    ]
      /      | ... \
   B(F,1) B(F,2)...B(F,n)
</pre>
<p>Where B(F,1) is the first boolean term with prefix F, and so on.</p>
<p>The intent here is to allow filtering on arbitrary (and, typically,
orthogonal) characteristics of the document. For instance, by adding
boolean terms &quot;Ttext/html&quot;, &quot;Ttext/plain&quot; and &quot;P/press&quot; you would be
filtering the probabilistic search for only documents that are both in
the &quot;/press&quot; site <em>and</em> which are either of MIME type text/html or
text/plain. (See below for more information about sites.)</p>
<p>If there is no probabilistic query, the boolean filter is promoted to
be the query, and the weighting scheme is set to boolean.  This has
the effect of applying the boolean filter to the whole database.</p>
<p>In order to add more boolean prefixes, you will need to alter the
<tt class="docutils literal"><span class="pre">index_file()</span></tt> function in omindex.cc. Currently omindex adds several
useful ones, detailed below.</p>
<p>Probabilistic terms are constructed from the title, body and keywords
of a document. (Not all document types support all three areas of
text.) Title terms are stored with position data starting at 0, body
terms starting 100 beyond title terms, and keyword terms starting 100
beyond body terms. This allows queries using positional data without
causing false matches across the different types of term.</p>
</div>
<div class="section" id="sites">
<h1>Sites</h1>
<p>Within a database, Omega supports multiple sites. These are recorded
using boolean terms (see 'Term construction', above) to allow
filtering on them.</p>
<p>Sites work by having all documents within them having a common base
URL. For instance, you might have two sites, one for your press area
and one for your product descriptions:</p>
<blockquote>
<ul class="simple">
<li>http://example.com/press/index.html</li>
<li>http://example.com/press/bigrelease.html</li>
<li>http://example.com/products/bigproduct.html</li>
<li>http://example.com/products/littleproduct.html</li>
</ul>
</blockquote>
<p>You could index all documents within http://example.com/press/ using a
site of '/press', and all within http://example.com/products/ using
'/products'.</p>
<p>Sites are also useful because omindex indexes documents through the
file system, not by fetching from the web server. If you don't have a
URL to file system mapping which puts all documents under one
hierarchy, you'll need to index each separate section as a site.</p>
<p>An obvious example of this is the way that many web servers map URLs
of the form &lt;http://example.com/~&lt;username&gt;/&gt; to a directory within
that user's home directory (such as ~&lt;username&gt;/pub on a Unix
system). In this case, you can index each user's home page separately,
as a site of the form '/~&lt;username&gt;'. You can then use boolean
filters to allow people to search only a specific home page (or a
group of them), or omit such terms to search everyone's pages.</p>
<p>Note that the site specified when you index is used to build the
complete URL that the results page links to. Thus while sites will
typically want to be relative to the hostname part of the URL (e.g.
'/site' rather than 'http://example.com/site'), you can use them
to have a single search across several different hostnames. This will
still work if you actually store each distinct hostname in a different
database.</p>
</div>
<div class="section" id="omindex-operation">
<h1>omindex operation</h1>
<p>omindex is fairly simple to use, for example:</p>
<pre class="literal-block">
omindex --db default --url http://example.com/ /var/www/example.com
</pre>
<p>For a full list of command line options supported, see <tt class="docutils literal"><span class="pre">man</span> <span class="pre">omindex</span></tt>
or <tt class="docutils literal"><span class="pre">omindex</span> <span class="pre">--help</span></tt>.</p>
<p>You <em>must</em> specify the database to index into (it's created if it doesn't
exist, but parent directories must exist).  You will often also want to specify
the base URL (which is used as the site, and can be relative to the hostname -
starts '/' - or absolute - starts with a scheme, e.g.
'http://example.com/products/').  If not specified, the base URL defaults to
<tt class="docutils literal"><span class="pre">/</span></tt>.</p>
<p>You also need to tell omindex which directory to index. This should be
either a single directory (in which case it is taken to be the
directory base of the entire site being indexed), or as two arguments,
the first being the directory base of the site being indexed, and the
second being a relative directory within that to index.</p>
<p>For instance, in the example above, if you separate your products by
size, you might end up with:</p>
<blockquote>
<ul class="simple">
<li>http://example.com/press/index.html</li>
<li>http://example.com/press/bigrelease.html</li>
<li>http://example.com/products/large/bigproduct.html</li>
<li>http://example.com/products/small/littleproduct.html</li>
</ul>
</blockquote>
<p>If the entire website is stored in the file system under the directory
/www/example, then you would probably index the site in two
passes, one for the '/press' site and one for the '/products' site. You
might use the following commands:</p>
<pre class="literal-block">
$ omindex -p --db /var/lib/omega/data/default --url /press /www/example/press
$ omindex -p --db /var/lib/omega/data/default --url /products /www/example/products
</pre>
<p>If you add a new large products, but don't want to reindex the whole of
the products section, you could do:</p>
<pre class="literal-block">
$ omindex -p --db /var/lib/omega/data/default --url /products /www/example/products large
</pre>
<p>and just the large products will be reindexed. You need to do it like that, and
not as:</p>
<pre class="literal-block">
$ omindex -p --db /var/lib/omega/data/default --url /products/large /www/example/products/large
</pre>
<p>because that would make the large products part of a new site,
'/products/large', which is unlikely to be what you want, as large
products would no longer come up in a search of the products
site. (Note that the --depth-limit option may come in handy if you have
sites '/products' and '/products/large', or similar.)</p>
<p>omindex has built-in support for indexing HTML, PHP, text files, and AbiWord
documents.  It can also index a number of other formats using external
programs.  Filter programs are run with CPU and memory limits to prevent a
runaway filter from blocking indexing of other files.</p>
<p>The following formats are currently supported (if you know of a reliable
filter which can extract text from another useful file format, please let us
know):</p>
<ul class="simple">
<li>HTML (.html, .htm, .shtml)</li>
<li>PHP (.php) - our HTML parser knows to ignore PHP code</li>
<li>text files (.txt, .text)</li>
<li>PDF (.pdf) if pdftotext is available (comes with xpdf)</li>
<li>PostScript (.ps, .eps, .ai) if ps2pdf (from ghostscript) and pdftotext (comes
with xpdf) are available</li>
<li>OpenOffice/StarOffice documents (.sxc, .stc, .sxd, .std, .sxi, .sti, .sxm,
.sxw, .sxg, .stw) if unzip is available</li>
<li>OpenDocument format documents (.odt, .ods, .odp, .odg, .odc, .odf, .odb,
.odi, .odm, .ott, .ots, .otp, .otg, .otc, .otf, .oti, .oth) if unzip is
available</li>
<li>MS Word documents (.doc, .dot) if antiword is available</li>
<li>MS Excel documents (.xls, .xlb, .xlt) if xls2csv is available (comes with
catdoc)</li>
<li>MS Powerpoint documents (.ppt, .pps) if catppt is available (comes with
catdoc)</li>
<li>MS Office 2007 documents (.docx, .dotx, .xlsx, .xlst, .pptx, .potx, .ppsx) if
unzip is available</li>
<li>Wordperfect documents (.wpd) if wpd2text is available (comes with libwpd)</li>
<li>MS Works documents (.wps, .wpt) if wps2text is available (comes with libwps)</li>
<li>AbiWord documents (.abw)</li>
<li>Compressed AbiWord documents (.zabw) if gzip is available</li>
<li>Rich Text Format documents (.rtf) if unrtf is available</li>
<li>Perl POD documentation (.pl, .pm, .pod) if pod2text is available</li>
<li>TeX DVI files (.dvi) if catdvi is available</li>
<li>DjVu files (.djv, .djvu) if djvutxt is available</li>
<li>XPS files (.xps) if unzip is available</li>
</ul>
<p>If you have additional extensions that represent one of these types, you need
to add an additional MIME mapping using the --mime-type option. For instance:</p>
<pre class="literal-block">
$ omindex --db /var/lib/omega/data/default --url /press /www/example/press  --mime-type doc:application/postscript
</pre>
<p>The syntax of --mime-type is 'ext:type', where ext is the extension of
a file of that type (everything after the last '.'), and type is one
of:</p>
<blockquote>
<ul class="simple">
<li>text/html</li>
<li>text/plain</li>
<li>text/rtf</li>
<li>text/x-perl</li>
<li>application/msword</li>
<li>application/pdf</li>
<li>application/postscript</li>
<li>application/vnd.ms-excel</li>
<li>application/vnd.ms-powerpoint</li>
<li>application/vnd.ms-works</li>
<li>application/vnd.ms-xpsdocument</li>
<li>application/vnd.oasis.opendocument.text</li>
<li>application/vnd.oasis.opendocument.spreadsheet</li>
<li>application/vnd.oasis.opendocument.presentation</li>
<li>application/vnd.oasis.opendocument.graphics</li>
<li>application/vnd.oasis.opendocument.chart</li>
<li>application/vnd.oasis.opendocument.formula</li>
<li>application/vnd.oasis.opendocument.database</li>
<li>application/vnd.oasis.opendocument.image</li>
<li>application/vnd.oasis.opendocument.text-master</li>
<li>application/vnd.oasis.opendocument.text-template</li>
<li>application/vnd.oasis.opendocument.spreadsheet-template</li>
<li>application/vnd.oasis.opendocument.presentation-template</li>
<li>application/vnd.oasis.opendocument.graphics-template</li>
<li>application/vnd.oasis.opendocument.chart-template</li>
<li>application/vnd.oasis.opendocument.formula-template</li>
<li>application/vnd.oasis.opendocument.image-template</li>
<li>application/vnd.oasis.opendocument.text-web</li>
<li>application/vnd.openxmlformats-officedocument.wordprocessingml.document</li>
<li>application/vnd.openxmlformats-officedocument.wordprocessingml.template</li>
<li>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</li>
<li>application/vnd.openxmlformats-officedocument.spreadsheetml.template</li>
<li>application/vnd.openxmlformats-officedocument.presentationml.presentation</li>
<li>application/vnd.openxmlformats-officedocument.presentationml.slideshow</li>
<li>application/vnd.openxmlformats-officedocument.presentationml.template</li>
<li>application/vnd.sun.xml.calc</li>
<li>application/vnd.sun.xml.calc.template</li>
<li>application/vnd.sun.xml.draw</li>
<li>application/vnd.sun.xml.draw.template</li>
<li>application/vnd.sun.xml.impress</li>
<li>application/vnd.sun.xml.impress.template</li>
<li>application/vnd.sun.xml.math</li>
<li>application/vnd.sun.xml.writer</li>
<li>application/vnd.sun.xml.writer.global</li>
<li>application/vnd.sun.xml.writer.template</li>
<li>application/vnd.wordperfect</li>
<li>application/x-abiword</li>
<li>application/x-abiword-compressed</li>
<li>application/x-dvi</li>
<li>image/vnd.djvu</li>
</ul>
</blockquote>
<p>If you wish to remove a MIME mapping, you can do this by omitting the type -
for example to not index .doc files, use: --mime-type doc:</p>
<p>The lookup of extensions in the MIME mappings is case sensitive, but if an
extension isn't found and includes upper case ASCII letters, they're converted
to lower case and the lookup is repeated, so you effectively get case
insensitive lookup for mappings specified with a lower-case extension, but
you can set different handling for differently cased variants if you need
to.</p>
<p>--duplicates configures how omindex handles duplicates (detected on
URL). 'ignore' means to ignore a document if it already appears to be
in the database; 'replace' means to replace the document in the
database with a new one by indexing this file, and 'duplicate' means
to index this file as a new document, leaving the previous one in the
database as well. The last strategy is very fast, but is liable to do
strange things to your results set. In general, 'ignore' is useful for
completely static documents (e.g. archive sites), while 'replace' is
the most generally useful.</p>
<p>With 'replace', omindex will remove any document it finds in the
database that it did not update - in other words, it will clear out
everything that doesn't exist any more. However if you are building up
an omega database with several runs of omindex, this is not
appropriate (as each run would delete the data from the previous run),
so you should use the --preserve-nonduplicates. Note that if you
choose to work like this, it is impossible to prune old documents from
the database using omindex. If this is a problem for you, an
alternative is to index each subsite into a different database, and
merge all the databases together when searching.</p>
<p>--depth-limit allows you to prevent omindex from descending more than
a certain number of directories.  If you wish to replicate the old
--no-recurse option, use ----depth-limit=1.</p>
</div>
<div class="section" id="html-parsing">
<h1>HTML Parsing</h1>
<p>The document <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> tag is used as the document title, the 'description'
META tag (if present) is used for the document snippet, and the 'keywords'
META tag (if present) is indexed as extra document text.</p>
<p>The HTML parser will look for the 'robots' META tag, and won't index pages
which are marked as <tt class="docutils literal"><span class="pre">noindex</span></tt> or <tt class="docutils literal"><span class="pre">none</span></tt>, for example any of the following:</p>
<pre class="literal-block">
&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot;&gt;
&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt;
&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt;
</pre>
<p>The parser also understand ht://dig comments to mark sections of the document
to not index (for example, you can use this to avoid indexing navigation links
or standard headers/footers) - for example:</p>
<pre class="literal-block">
Index this bit &lt;!--htdig_noindex--&gt;but &lt;b&gt;not&lt;/b&gt; this&lt;!--/htdig_noindex&gt;
</pre>
</div>
<div class="section" id="boolean-terms">
<h1>Boolean terms</h1>
<p>omindex will create the following boolean terms when it indexes a
document:</p>
<dl class="docutils">
<dt>T</dt>
<dd>MIME type</dd>
<dt>H</dt>
<dd>hostname of site (if supplied - this term won't exist if you index a
site with base URL '/press', for instance)</dd>
<dt>P</dt>
<dd>path of site (i.e. the rest of the site base URL)</dd>
<dt>U</dt>
<dd>full URL of indexed document - if the resulting term would be &gt; 240
characters, a hashing scheme is used to prevent omindex overflowing
the Xapian term length limit.</dd>
<dt>D</dt>
<dd>date (numeric format: YYYYMMDD)
date can also have the magical form &quot;latest&quot; - a document indexed
by the term Dlatest matches any date-range without an end date.
You can index dynamic documents which are always up to date
with Dlatest and they'll match as expected.  (If you use sort by date,
you'll probably also want to set the value containing the timestamp to
a &quot;max&quot; value so dynamic documents match a date in the far future).</dd>
<dt>M</dt>
<dd>month (numeric format: YYYYMM)</dd>
<dt>Y</dt>
<dd>year (four digits)</dd>
</dl>
</div>
<div class="section" id="omega-configuration">
<h1>omega configuration</h1>
<p>Most of the omega CGI configuration is dynamic, by setting CGI
parameters. However some things must be configured using a
configuration file.  The configuration file is searched for in
various locations:</p>
<blockquote>
<ul class="simple">
<li>Firstly, if the &quot;OMEGA_CONFIG_FILE&quot; environment variable is
set, its value is used as the full path to a configuration file
to read.</li>
<li>Next (if the environment variable is not set, or the file pointed
to is not present), the file &quot;omega.conf&quot; in the same directory as
the Omega CGI is used.</li>
<li>Next (if neither of the previous steps found a file), the file
&quot;${sysconfdir}/omega.conf&quot; (e.g. /etc/omega.conf on Linux systems)
is used.</li>
<li>Finally, if no configuration file is found, default values are used.</li>
</ul>
</blockquote>
<p>The format of the file is very simple: a line per option, with the
option name followed by its value, separated by a whitespace.  Blank
lines are ignored.  If the first non-whitespace character on a line
is a '#', omega treats the line as a comment and ignores it.</p>
<p>The current options are 'database_dir' (the directory containing all the
Omega databases), 'template_dir' (the directory containing the OmegaScript
templates), and 'log_dir' (the directory which the OmegaScript $log command
writes log files to).</p>
<p>The default values (used if no configuration file is found) are:</p>
<pre class="literal-block">
database_dir /var/lib/omega/data
template_dir /var/lib/omega/templates
log_dir /var/log/omega
</pre>
<p>Note that, with apache, environment variables may be set using mod_env, and
with apache 1.3.7 or later this may be used inside a .htaccess file.  This
makes it reasonably easy to share a single system installed copy of Omega
between multiple users.</p>
</div>
<div class="section" id="supplied-templates">
<h1>Supplied Templates</h1>
<p>The OmegaScript templates supplied with Omega are:</p>
<blockquote>
<ul class="simple">
<li>query - This is the default template, providing a typical Web search
interface.</li>
<li>topterms - This is just like query, but provides a &quot;top terms&quot; feature
which suggests terms the user might want to add to their query to
obtain better results.</li>
<li>godmode - Allows you to inspect a database showing which terms index
each document, and which documents are indexed by each term.</li>
<li>opensearch - Provides results in OpenSearch format (for more details
see <a class="reference external" href="http://www.opensearch.org/">http://www.opensearch.org/</a>).</li>
<li>xml - Provides results in a custom XML format.</li>
</ul>
</blockquote>
<p>There are also &quot;helper fragments&quot; used by the templates above:</p>
<blockquote>
<ul class="simple">
<li>inc/anyalldropbox - Provides a choice of matching &quot;any&quot; or &quot;all&quot; terms
by default as a drop down box.</li>
<li>inc/anyallradio - Provides a choice of matching &quot;any&quot; or &quot;all&quot; terms
by default as radio buttons.</li>
<li>toptermsjs - Provides some JavaScript used by the topterms template.</li>
</ul>
</blockquote>
</div>
<div class="section" id="document-data-construction">
<h1>Document data construction</h1>
<p>This is only useful if you need to inject your own documents into the
database independently of omindex, such as if you are indexing
dynamically-generated documents that are served using a server-side
system such as PHP or ASP, but which you can determine the contents of
in some way, such as documents generated from reasonably static
database contents.</p>
<p>The document data field stores some summary information about the
document, in the following (sample) format:</p>
<pre class="literal-block">
url=&lt;baseurl&gt;
sample=&lt;sample&gt;
caption=&lt;title&gt;
type=&lt;mimetype&gt;
</pre>
<p>Further fields may be added (although omindex doesn't currently add any
others), and may be looked up from OmegaScript using the $field{}
command.</p>
<p>As of Omega 0.9.3, you can alternatively add something like this near the
start of your OmegaScript template:</p>
<pre class="literal-block">
$set{fieldnames,$split{caption sample url}}
</pre>
<p>Then you need only give the field values in the document data, which can
save a lot of space in a large database.  With the setting of fieldnames
above, the first line of document data can be accessed with $field{caption},
the second with $field{sample}, and the third with $field{url}.</p>
</div>
</div>
</body>
</html>
